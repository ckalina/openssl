=pod

=head1 NAME

CRYPTO_THREAD_new, CRYPTO_THREAD_join, CRYPTO_THREAD_exit,
CRYPTO_THREAD_INTERN_enable, CRYPTO_THREAD_INTERN_disable,
CRYPTO_THREAD_INTERN_new, CRYPTO_THREAD_INTERN_join, CRYPTO_THREAD_INTERN_exit,
CRYPTO_THREAD_EXTERN_enable, CRYPTO_THREAD_EXTERN_disable,
CRYPTO_THREAD_EXTERN_provide, CRYPTO_THREAD_EXTERN_add_job,
CRYPTO_THREAD_EXTERN_join, CRYPTO_THREAD_EXTERN_return,
CRYPTO_SIGNAL_block

=head1 SYNOPSIS

 #include <openssl/crypto.h>

 void * CRYPTO_THREAD_new(CRYPTO_THREAD_ROUTINE start, void *data, int *ret);
 int    CRYPTO_THREAD_join(void * thread);

 int    CRYPTO_THREAD_INTERN_enable(CRYPTO_SIGNAL_PROPS *props);
 int    CRYPTO_THREAD_INTERN_disable();
 void * CRYPTO_THREAD_INTERN_new(CRYPTO_THREAD_ROUTINE start, void * data,
                                 int * ret);
 int    CRYPTO_THREAD_INTERN_join(void * thread, unsigned long * retval);
 void   CRYPTO_THREAD_INTERN_exit(unsigned long retval);

 int    CRYPTO_THREAD_EXTERN_enable(CRYPTO_SIGNAL_PROPS *props);
 int    CRYPTO_THREAD_EXTERN_disable();
 void * CRYPTO_THREAD_EXTERN_provide(int * ret);
 void * CRYPTO_THREAD_EXTERN_add_job(CRYPTO_THREAD_ROUTINE task, void * data);
 int    CRYPTO_THREAD_EXTERN_join(void * task_id, unsigned long * retval);

 int    CRYPTO_SIGNAL_block(int signal, void (*callback)(int));

 int CRYPTO_atomic_add(int *val, int amount, int *ret, CRYPTO_RWLOCK *lock);

=head1 DESCRIPTION

OpenSSL supports multi-threaded algorithms and thread creation/management.
This feature is disabled by default and needs to be explicitly enabled. OpenSSL
will not enable multi-threading on its own under any circumstances, even if
multi-threaded mode is requested via ctrl/OSSL_PARAM (for instance, Argon2
memory-hard KDF supports multi-threading and accepts number of threads as an
argument; it will not enable threads for you).

Whenever threading is enabled (and until explicit disable), SIGINT/SIGTERM on
POSIX platforms and CTRL_C_EVENT/CTRL_BREAK_EVENT on Windows platforms are
masked by default. To provide callbacks or disable signal masking, see
CRYPTO_THREAD_*_enable and CRYPTO_SIGNAL_PROPS.

As a user of OpenSSL, you get to decide whether OpenSSL is a) free to create
threads itself (internal threads), or is b) required to use a limited number
of threads that you create (external threads).

To enable internal threads, call CRYPTO_THREAD_INTERN_enable(). To disable,
call CRYPTO_THREAD_INTERN_disable(). Nothing is required of your application
beyond the former call.

To enable external threads, call CRYPTO_THREAD_EXTERN_enable(). This alone is
not sufficient as you need to provide worker threads to OpenSSL. Use
CRYPTO_THREAD_EXTERN_provide() to spawn a single new worker. This worker will
remain idle until it's tasked by OpenSSL. From an internal point of view,
whenever OpenSSL wishes to create a new thread, it adds the task into a queue
and awaits for a free worker.

OpenSSL algorithms may use threading seamlessly and needn't concern themselves
with the distinction between internal vs. external -- use wrappers
CRYPTO_THREAD_new(), CRYPTO_THREAD_join(), CRYPTO_THREAD_exit().

=cut
